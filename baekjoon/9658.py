'''아이디어 :
잠시 상근, 찬영이는 잊고 선/후의 경우로 생각해보자. dp[i]에 대하여 선이 이기면 0, 후가 이기면 1을 넣는다.
만약 n=1일 때, 선은 돌을 하나 가져가야 하므로 무조건 패배한다.
즉, dp[1]=1
만약 n=2일 때, 선이 돌을 하나 가져가고, 후가 돌을 하나 가져가야 하므로 후가 무조건 패배한다.
즉, dp[2]=0
이렇게 하면 dp[3]=0, dp[4]=1이 나온다.
dp[5]부터는 전형적인 dp 방식으로 접근한다.
dp[5]에서, 선은 돌을 1개/3개/4개 집을 수 있다.
만약 선이 돌을 1개 집으면, 후는 dp[5-1](즉, dp[4])의 선이 된다.(돌이 4개 남아있는 상태에서, 본인이 선이 되므로.)
만약 선이 돌을 3개 집으면, 후는 dp[5-3](즉, dp[2])의 선이 된다.
만약 선이 돌을 4개 집으면, 후는 dp[5-4](즉, dp[1])의 선이 된다.
이때, 선은 자신이 이길 수 있는 경우가 있다면 반드시 그 경우를 선택할 것이다.
즉, 선은 dp[5-i]=1이 되는 경우를 무조건 선택해야 한다. (dp[5-i]에서, 선후가 바뀌어서 선이 후가 되므로, 자신이 이기려면 1이어야 한다.)
반대로, 후는 dp[5-1],dp[5-3],dp[5-4]가 모두 0이 되는 경우에만 승리할 수 있다.
이를 구현하면 아래와 같다.
'''
n=int(input())
if n<4:
    dp=[0]*5
else:
    dp=[0]*(n+1)
#n=4까지는 직접 한다.
dp[1]=1
dp[2]=0
dp[3]=1
dp[4]=0
for i in range(5,n+1):
    #후는 dp[i-1],dp[i-3],dp[i-4]가 모두 0일 때에만 승리할 수 있으므로.
    if (dp[i-1]==0 and dp[i-3]==0 and dp[i-4]==0):
        dp[i]=1
#선=상근이므로 dp[n]=0이면 SK를, 아니면 CY를 출력한다.
if dp[n]==0:
    print('SK')
else:
    print('CY')