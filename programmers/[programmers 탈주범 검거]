#include<iostream>
#include<queue>
#define fastio ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
using namespace std;

struct three {
	int y, x, t;
};

int sero, garo, sy, sx, jehan;
int board[51][51];
bool visit[51][51];
int dy1[4] = { -1,1,0,0 };
int dx1[4] = { 0,0,-1,1 };
int dy2[2] = { -1,1};
int dx2[2] = { 0,0 };
int dy3[2] = { 0,0 };
int dx3[2] = { -1,1 };
int dy4[2] = { -1,0 };
int dx4[2] = { 0,1 };
int dy5[2] = { 1,0 };
int dx5[2] = { 0,1 };
int dy6[2] = { 1,0 };
int dx6[2] = { 0,-1 };
int dy7[2] = { -1,0 };
int dx7[2] = { 0,-1 };
void visitClear() {
	int i, k;
	for (i = 1; i <= sero; ++i) {
		for (k = 1; k <= garo; ++k) {
			visit[i][k] = false;
		}
	}
}
 
bool inBoard(int y, int x) {
	if (y >= 1 && y <= sero && x >= 1 && x <= garo) {
		return true;
	}
	return false;
}

bool mustUp(int y, int x) {
	int ny = y - 1, nx = x;
	if (!inBoard(ny, nx)) return false;
	if (board[ny][nx] == 1 || board[ny][nx] == 2 || board[ny][nx] == 5 || board[ny][nx] == 6) return true;
	return false;
}

bool mustDown(int y, int x) {
	int ny = y + 1, nx = x;
	if (!inBoard(ny, nx)) return false;
	if (board[ny][nx] == 1 || board[ny][nx] == 2 || board[ny][nx] == 4 || board[ny][nx] == 7) return true;
	return false;
}

bool mustLeft(int y, int x) {
	int ny = y , nx = x-1;
	if (!inBoard(ny, nx)) return false;
	if (board[ny][nx] == 1 || board[ny][nx] == 3 || board[ny][nx] == 4 || board[ny][nx] == 5) return true;
	return false;
}

bool mustRight(int y, int x) {
	int ny = y, nx = x + 1;
	if (!inBoard(ny, nx)) return false;
	if (board[ny][nx] == 1 || board[ny][nx] == 3 || board[ny][nx] == 6 || board[ny][nx] == 7) return true;
	return false;
}

int solve() {
	visitClear();
	queue<three> q;
	sy++; sx++;
	visit[sy][sx] = true;
	q.push({ sy,sx,1 });
	int y, x, t,i, ny, nx;
	while (!q.empty()) {
		y = q.front().y;
		x = q.front().x;
		t = q.front().t;
		q.pop();
		//cout << y << "," << x << " : " << t << endl;
		if (board[y][x] == 1) {			//십자
			ny = y + dy1[0];
			nx = x + dx1[0];
			if (mustUp(y,x)&&!visit[ny][nx] && (t + 1) <= jehan) {
				visit[ny][nx] = true;
				q.push({ ny, nx, t + 1 });
			}
			ny = y + dy1[1];
			nx = x + dx1[1];
			if (mustDown(y, x) && !visit[ny][nx] && (t + 1) <= jehan) {
				visit[ny][nx] = true;
				q.push({ ny, nx, t + 1 });
			}
			ny = y + dy1[2];
			nx = x + dx1[2];
			if (mustLeft(y, x) && !visit[ny][nx] && (t + 1) <= jehan) {
				visit[ny][nx] = true;
				q.push({ ny, nx, t + 1 });
			}
			ny = y + dy1[3];
			nx = x + dx1[3];
			if (mustRight(y, x) && !visit[ny][nx] && (t + 1) <= jehan) {
				visit[ny][nx] = true;
				q.push({ ny, nx, t + 1 });
			}
		}
		else if (board[y][x] == 2) {	//세로	
			ny = y + dy2[0];
			nx = x + dx2[0];
			if (mustUp(y, x) && !visit[ny][nx] && (t + 1) <= jehan) {
				visit[ny][nx] = true;
				q.push({ ny, nx, t + 1 });
			}
			ny = y + dy2[1];
			nx = x + dx2[1];
			if (mustDown(y, x) && !visit[ny][nx] && (t + 1) <= jehan) {
				visit[ny][nx] = true;
				q.push({ ny, nx, t + 1 });
			}
		}
		else if (board[y][x] == 3) {	//가로	
			ny = y + dy3[0];
			nx = x + dx3[0];
			if (mustLeft(y, x) && !visit[ny][nx] && (t + 1) <= jehan) {
				visit[ny][nx] = true;
				q.push({ ny, nx, t + 1 });
			}
			ny = y + dy3[1];
			nx = x + dx3[1];
			if (mustRight(y, x) && !visit[ny][nx] && (t + 1) <= jehan) {
				visit[ny][nx] = true;
				q.push({ ny, nx, t + 1 });
			}
		}
		else if (board[y][x] == 4) {	//ㄴ	
			ny = y + dy4[0];
			nx = x + dx4[0];
			if (mustUp(y, x) && !visit[ny][nx] && (t + 1) <= jehan) {
				visit[ny][nx] = true;
				q.push({ ny, nx, t + 1 });
			}
			ny = y + dy4[1];
			nx = x + dx4[1];
			if (mustRight(y, x) && !visit[ny][nx] && (t + 1) <= jehan) {
				visit[ny][nx] = true;
				q.push({ ny, nx, t + 1 });
			}
		}
		else if (board[y][x] == 5) {	//ㄴ 상하대칭	
			ny = y + dy5[0];
			nx = x + dx5[0];
			if (mustDown(y, x) && !visit[ny][nx] && (t + 1) <= jehan) {
				visit[ny][nx] = true;
				q.push({ ny, nx, t + 1 });
			}
			ny = y + dy5[1];
			nx = x + dx5[1];
			if (mustRight(y, x) && !visit[ny][nx] && (t + 1) <= jehan) {
				visit[ny][nx] = true;
				q.push({ ny, nx, t + 1 });
			}
		}
		else if (board[y][x] == 6) {	//ㄱ	
			ny = y + dy6[0];
			nx = x + dx6[0];
			if (mustDown(y, x) && !visit[ny][nx] && (t + 1) <= jehan) {
				visit[ny][nx] = true;
				q.push({ ny, nx, t + 1 });
			}
			ny = y + dy6[1];
			nx = x + dx6[1];
			if (mustLeft(y, x) && !visit[ny][nx] && (t + 1) <= jehan) {
				visit[ny][nx] = true;
				q.push({ ny, nx, t + 1 });
			}
		}
		else {							//ㄱ 상하대칭	
			ny = y + dy7[0];
			nx = x + dx7[0];
			if (mustUp(y, x) && !visit[ny][nx] && (t + 1) <= jehan) {
				visit[ny][nx] = true;
				q.push({ ny, nx, t + 1 });
			}
			ny = y + dy7[1];
			nx = x + dx7[1];
			if (mustLeft(y, x) && !visit[ny][nx] && (t + 1) <= jehan) {
				visit[ny][nx] = true;
				q.push({ ny, nx, t + 1 });
			}
		}
	}
	int dap = 0,k;
	for (i = 1; i <= sero; ++i) {
		for (k = 1; k <= garo; ++k) {
			if (visit[i][k]) {
				dap++;
			}
		}
	}
	return dap;
}

int main(void)
{
	fastio;
	int i, k, testcase, t;
	cin >> testcase;
	for (t = 1; t <= testcase; ++t) {
		cin >> sero >> garo >> sy >> sx >> jehan;
		for (i = 1; i <= sero; ++i) {
			for (k = 1; k <= garo; ++k) {
				cin >> board[i][k];
			}
		}
		cout << "#" << t << " " << solve() << "\n";
	}
	return 0;
}
