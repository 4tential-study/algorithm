#2436. 공약수(백준, 골드 5)
'''
아이디어 :
0. 어떤 x,y에 대하여 (x,y의 최소공배수) = (x*y)/(x,y의 최대공약수)
= 즉, (x,y의 최소공배수)*(x,y의 최대공약수) = (x*y)
= 즉, (a*b) = (a와 b를 최대공약수와 최소공배수로 갖는 두 수의 곱)
따라서,
1. a*b의 약수 쌍을 전부 구한다.
2. 해당 쌍이 a와 b를 최대공약수, 최소공배수로 갖지 않는 경우에 대비해 검증을 거친다.
3. 이때, 검증은 유클리드 호제법을 이용한다.
'''
#최대공약수와 최소공배수의 경우 '유클리드 호제법'을 공부하면 매우 쉽고 효율적으로 접근할 수 있다!
'''
유클리드 호제법이란?
a>b인 두 정수 a,b에 대하여 a와 b의 최대공약수는 a를 b로 나눈 나머지인 r에 대하여 b와 r의 최대공약수와 같다.
즉, r=a%b인 r에 대하여 a와 b의 최대공약수 = b와 r의 최대공약수.
해당 이론을 적용시켜 계속해서 수의 크기를 줄여가보자.
r'=b%r인 r'에 대하여 r과 r'의 최대공약수는 b와 r의 최대공약수와 같다. 즉
"a와 b의 최대공약수" = "b와 r의 최대공약수" = "r과 r'의 최대공약수" = "r'과 r''의 최대공약수"...
이 과정을 반복하다보면 나머지가 0이 되는 값이 나온다. 만약 r%r'=0이라면 r과 r'의 최대공약수는 r'이 된다.
이 규칙에 따라서, a와 b의 최대공약수 또한 r'이 된다.
최소공배수의 경우, a*b를 최대공약수로 나누어준 값이 된다.
'''
a,b=map(int,input().split())
num=a*b
pair=[]
#1.
for i in range(1,int(num**(1/2))+1):
    #i가 a*b의 약수인 경우에 대하여
    if num%i==0:
        #2. 검증을 위해 두 수 중 작은 수를 small로 지정해 i를, 큰 수를 large로 지정해 num//i를 대입
        small=i
        large=num//small
        r=0
        #3. 유클리드 호제법에 따라 r이 대입될 small이 0이 되면 large가 최대공약수이다.
        while small!=0:
            r=large%small
            large=small
            small=r
        #large를 그냥 써도 되지만 이해를 돕기 위해 gcd와 lcm에 각각 값 대입
        gcd=large
        lcm=num//gcd
        #유클리드 호제법을 통해 구한 최대공약수와 최소공배수가 a,b와 각각 일치하는지 확인, 두 수의 합이 가장 작은 값을 반환해야 하므로 합과 두 값을 함께 반환
        if a==gcd and b==lcm:
            pair.append((i+num//i,i,num//i))
pair.sort()
print(pair[0][1],pair[0][2])